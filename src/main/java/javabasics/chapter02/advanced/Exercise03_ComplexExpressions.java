package javabasics.chapter02.advanced;

/**
 * Chapter 02 - 연산자 (Operators) - 고급
 * 연습문제 3: 복합 표현식과 연산자 우선순위 마스터
 * 
 * <h3>학습 목표:</h3>
 * <ul>
 *   <li>연산자 우선순위와 결합 방향 완벽 이해</li>
 *   <li>복잡한 표현식의 평가 순서 예측 능력 향상</li>
 *   <li>여러 연산자를 조합한 실무 패턴 학습</li>
 *   <li>가독성과 성능을 고려한 표현식 작성법</li>
 * </ul>
 * 
 * <h3>연산자 우선순위 (높음 → 낮음):</h3>
 * <table border="1">
 *   <tr><th>순위</th><th>연산자</th><th>설명</th></tr>
 *   <tr><td>1</td><td>++, --, +, -, ~, !</td><td>단항 연산자</td></tr>
 *   <tr><td>2</td><td>*, /, %</td><td>곱셈, 나눗셈, 나머지</td></tr>
 *   <tr><td>3</td><td>+, -</td><td>덧셈, 뺄셈</td></tr>
 *   <tr><td>4</td><td><<, >>, >>></td><td>비트 시프트</td></tr>
 *   <tr><td>5</td><td><, >, <=, >=</td><td>관계 연산자</td></tr>
 *   <tr><td>6</td><td>==, !=</td><td>동등 비교</td></tr>
 *   <tr><td>7</td><td>&</td><td>비트 AND</td></tr>
 *   <tr><td>8</td><td>^</td><td>비트 XOR</td></tr>
 *   <tr><td>9</td><td>|</td><td>비트 OR</td></tr>
 *   <tr><td>10</td><td>&&</td><td>논리 AND</td></tr>
 *   <tr><td>11</td><td>||</td><td>논리 OR</td></tr>
 *   <tr><td>12</td><td>? :</td><td>삼항 연산자</td></tr>
 *   <tr><td>13</td><td>=, +=, -=, *=, /=, %=</td><td>대입 연산자</td></tr>
 * </table>
 * 
 * <h3>💡 핵심 원칙:</h3>
 * <ul>
 *   <li>같은 우선순위는 왼쪽에서 오른쪽으로 평가</li>
 *   <li>대입 연산자는 오른쪽에서 왼쪽으로 평가</li>
 *   <li>괄호로 우선순위를 명시적으로 지정 가능</li>
 *   <li>복잡한 식은 가독성을 위해 분리 권장</li>
 * </ul>
 * 
 * @author 자바 기초 학습
 * @version 1.0
 * @since Chapter 02 Advanced
 */
public class Exercise03_ComplexExpressions {
    public static void main(String[] args) {
        /*
         * ==========================================
         * 문제 3-1: 연산자 우선순위 이해
         * ==========================================
         * 복잡한 산술 표현식의 단계별 평가
         * 
         * [우선순위에 따른 계산 순서]
         * 1. 20 * 3 = 60 (곱셈)
         * 2. 40 / 5 = 8 (나눗셈)
         * 3. 8 % 3 = 2 (나머지)
         * 4. 10 + 60 = 70 (덧셈)
         * 5. 70 - 2 = 68 (뺄셈)
         * 
         * 💡 TIP: 복잡한 식은 괄호로 명확히 표현
         */
        int result1 = 10 + 20 * 3 - 40 / 5 % 3;
        System.out.println("10 + 20 * 3 - 40 / 5 % 3 = " + result1);
        
        // 단계별 계산 과정
        System.out.println("단계 1: 20 * 3 = " + (20 * 3));
        System.out.println("단계 2: 40 / 5 = " + (40 / 5));
        System.out.println("단계 3: 8 % 3 = " + (8 % 3));
        System.out.println("단계 4: 10 + 60 - 2 = " + (10 + 60 - 2));
        
        /*
         * ==========================================
         * 문제 3-2: 논리 연산자와 관계 연산자 조합
         * ==========================================
         * 여러 조건을 조합한 복합 논리식
         * 
         * [평가 순서]
         * 1. x < y = 5 < 10 = true
         * 2. y < z = 10 < 15 = true
         * 3. x < y && y < z = true && true = true
         * 4. x + y = 5 + 10 = 15
         * 5. x + y == z = 15 == 15 = true
         * 6. true || true = true
         * 
         * 🔑 핵심: && 가 || 보다 우선순위 높음
         */
        int x = 5, y = 10, z = 15;
        boolean complex1 = x < y && y < z || x + y == z;
        System.out.println("\nx < y && y < z || x + y == z = " + complex1);
        
        /*
         * ==========================================
         * 문제 3-3: 비트 연산과 산술 연산 조합
         * ==========================================
         * 비트 시프트와 비트 마스킹을 활용한 계산
         * 
         * [계산 과정]
         * a = 8 = 1000₂
         * a << 2 = 100000₂ = 32 (8 × 4)
         * a >> 1 = 0100₂ = 4 (8 ÷ 2)
         * a & 3 = 1000₂ & 0011₂ = 0000₂ = 0
         * 결과: 32 + 4 - 0 = 36
         * 
         * 🎯 실무 활용: 빠른 계산, 비트 필드 처리
         */
        int a = 8;  // 1000 in binary
        int result2 = (a << 2) + (a >> 1) - (a & 3);
        System.out.println("\n(8 << 2) + (8 >> 1) - (8 & 3) = " + result2);
        System.out.println("분석: 32 + 4 - 0 = " + result2);
        
        /*
         * ==========================================
         * 문제 3-4: 증감 연산자가 포함된 복잡한 식
         * ==========================================
         * 전위/후위 증감 연산자의 복잡한 조합
         * 
         * [단계별 평가]
         * 초기값: p=5, q=3
         * 1. ++p = 6 (p는 6이 됨)
         * 2. q-- = 3 사용 (q는 2가 됨)
         * 3. 6 * 3 = 18
         * 4. p++ = 6 사용 (p는 7이 됨)
         * 5. --q = 1 (q는 1이 됨)
         * 6. 18 + 6 - 1 = 23
         * 
         * ⚠️ 경고: 이런 복잡한 식은 실무에서 피해야 함
         * 💡 권장: 명확하고 단순한 코드 작성
         */
        int p = 5, q = 3;
        int result3 = ++p * q-- + p++ - --q;
        System.out.println("\np=5, q=3 초기값");
        System.out.println("++p * q-- + p++ - --q = " + result3);
        System.out.println("최종 p = " + p + ", q = " + q);
        
        /*
         * ==========================================
         * 문제 3-5: 삼항 연산자와 다른 연산자 조합
         * ==========================================
         * 삼항 연산자를 포함한 복합 표현식
         * 
         * [계산 과정]
         * 1. num1 > num2 ? num1 : num2 = 10 > 20 ? 10 : 20 = 20
         * 2. 20 * 2 = 40
         * 3. num1 < num2 ? 5 : 10 = 10 < 20 ? 5 : 10 = 5
         * 4. 40 + 5 = 45
         * 
         * 📌 활용: 조건부 계산, 동적 값 선택
         */
        int num1 = 10, num2 = 20;
        int result4 = (num1 > num2 ? num1 : num2) * 2 + (num1 < num2 ? 5 : 10);
        System.out.println("\n복잡한 삼항 연산 결과: " + result4);
        
        /*
         * ==========================================
         * 문제 3-6: 문자열 연결과 산술 연산
         * ==========================================
         * + 연산자의 이중 역할 이해
         * 
         * [두 가지 결과의 차이]
         * 1. "결과: " + val1 + val2
         *    = "결과: " + 10 + 20
         *    = "결과: 10" + 20
         *    = "결과: 1020" (문자열 연결)
         * 
         * 2. "결과: " + (val1 + val2)
         *    = "결과: " + (10 + 20)
         *    = "결과: " + 30
         *    = "결과: 30" (산술 연산 후 연결)
         * 
         * ⚠️ 주의: 문자열과 숫자의 + 연산 순서
         */
        int val1 = 10, val2 = 20;
        String result5 = "결과: " + val1 + val2;  // 문자열 연결
        String result6 = "결과: " + (val1 + val2);  // 산술 연산 후 연결
        System.out.println("\n" + result5);
        System.out.println(result6);
        
        /*
         * ==========================================
         * 문제 3-7: 복합 대입 연산자와 조건식
         * ==========================================
         * 조건에 따른 동적 값 누적
         * 
         * [보너스 점수 로직]
         * - 80점 이상: 10점 보너스
         * - 80점 미만: 5점 보너스
         * 
         * 계산: score = 75
         * score += 75 >= 80 ? 10 : 5
         * score += 5
         * score = 80
         * 
         * 🎯 활용: 성과 평가, 포인트 적립
         */
        int score = 75;
        score += score >= 80 ? 10 : 5;
        System.out.println("\n보너스 점수 적용 후: " + score);
        
        /*
         * ==========================================
         * 문제 3-8: 실전 예제 - 날짜 계산
         * ==========================================
         * 월별 일수 계산 (윤년 고려)
         * 
         * [월별 일수 규칙]
         * - 2월: 윤년 29일, 평년 28일
         * - 4,6,9,11월: 30일
         * - 나머지: 31일
         * 
         * [중첩 삼항 연산자 구조]
         * 1. 2월인가?
         *    - 윤년인가? 29 : 28
         * 2. 아니면
         *    - 30일인 달인가? 30 : 31
         * 
         * 📅 실무: 달력 앱, 일정 관리 시스템
         */
        int year = 2024, month = 2;
        int daysInMonth = month == 2 ? 
                         (year % 4 == 0 && year % 100 != 0 || year % 400 == 0 ? 29 : 28) :
                         (month == 4 || month == 6 || month == 9 || month == 11 ? 30 : 31);
        System.out.println("\n" + year + "년 " + month + "월의 일수: " + daysInMonth);
        
        /*
         * ==========================================
         * 문제 3-9: 비트 플래그와 조건 검사
         * ==========================================
         * 비트 연산을 활용한 복수 플래그 검사
         * 
         * [플래그 설정]
         * FLAG_A = 001 (1)
         * FLAG_B = 010 (2)
         * FLAG_C = 100 (4)
         * flags = FLAG_A | FLAG_C = 101 (5)
         * 
         * [검사 로직]
         * 1. 모든 플래그 보유: flags가 111을 포함하는가?
         * 2. 하나라도 보유: flags가 0이 아닌가?
         * 
         * 🎮 활용: 게임 설정, 권한 관리, 옵션 필터링
         */
        final int FLAG_A = 1;  // 001
        final int FLAG_B = 2;  // 010
        final int FLAG_C = 4;  // 100
        
        int flags = FLAG_A | FLAG_C;  // 101
        boolean hasAllFlags = (flags & (FLAG_A | FLAG_B | FLAG_C)) == (FLAG_A | FLAG_B | FLAG_C);
        boolean hasAnyFlag = (flags & (FLAG_A | FLAG_B | FLAG_C)) != 0;
        
        System.out.println("\n모든 플래그 보유: " + hasAllFlags);
        System.out.println("최소 하나의 플래그 보유: " + hasAnyFlag);
        
        /*
         * ==========================================
         * 문제 3-10: 복잡한 수식 평가
         * ==========================================
         * 수학 함수와 삼항 연산자를 포함한 복합 수식
         * 
         * [계산 과정]
         * 1. Math.pow(3.5, 2) = 12.25 (3.5²)
         * 2. d2 * 10 = 2.5 * 10 = 25
         * 3. Math.sqrt(25) = 5.0 (√25)
         * 4. d1 > d2 ? d1-d2 : d2-d1 = 3.5-2.5 = 1.0
         * 5. 12.25 + 5.0 - 1.0 = 16.25
         * 
         * 📊 활용: 과학 계산, 엔지니어링 응용, 데이터 분석
         */
        double d1 = 3.5, d2 = 2.5;
        double complexResult = Math.pow(d1, 2) + Math.sqrt(d2 * 10) - (d1 > d2 ? d1 - d2 : d2 - d1);
        System.out.println("\n복잡한 수식 결과: " + complexResult);
    }
}